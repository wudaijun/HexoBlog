---
title: 用MQ简化网络拓扑的一些尝试
layout: post
category: gameserver
tags: gameserver
---

聊聊最近对引入MQ以简化网络拓扑的一些思考，在目前这套项目架构诞生初期，基于当时的游戏类型和项目需求，架构做得相对简单，设计上尽可能通过goroutine而不是节点来并发，节点间用ETCD做服务发现，用gRPC做节点通信，在单向依赖，弱藕合的情况下，基本能够满足需求。对于个别强耦合的节点交互，使用gRPC Stream来建立双工连接。

随着游戏类型和业务需求的变更，跨服功能增多，节点划分越来越细，藕合越来越重，网络拓扑也越来越复杂。gRPC Stream不再能很好地胜任。

因此我们考虑用一套新的节点交互方案，大概有两个思路:

<!--more-->

1. 写一套完备的TCP网络库(包含服务发现，自动重连，编解码，心跳，流控等)，用于统一节点间甚至Gateway与Client间的网络交互
2. 使用MQ解耦集群内节点交互，将网状网络化为星形网络，简化网络拓扑

在对方案一进行几天的尝试后，我们最终放弃了TCP方案，主要有以下几个问题:

1. 网络拓扑完全交给了应用层去维护，开发者需要谨慎规划和约束，避免形成全联通
2. 由于不是全联通网络，A->B的消息可能需要经由一个甚至多个中间节点路由才能到达，并且这类路由信息只能逻辑层维护
3. 某些业务场景下，节点路由和依赖可能是动态的，如跨服匹配战场，此时需要动态建立/销毁连接以维护动态路由

就前面几个问题来说，MQ显然是更好的解决方案，相比TCP，它有以下优势:

1. 将 0-N 跳的路由网络的模型，统一为一跳，即通过中间件即可直达任意节点，在路由和全联通之间找到一个平衡点
2. 发布订阅模型，为应用层提供了非常大的灵活度: 单向依赖/双向依赖，扇入/扇出，负载均衡，批量发布(主题匹配)等

消息中间件能够比较好地向应用层屏蔽节点路由的问题，但它并不能完全替代ETCD+gRPC，两套方案可以在不同的应用场景搭配使用。

在对几种主流消息中间件进行评估之后，我们目前选定[nats](https://github.com/nats-io/nats-server)，它的优点是基于golang编写，轻量级，高性能，低延迟，缺点是不支持消息持久化，即最多一次投递语义，[nats-streaming](https://github.com/nats-io/nats-streaming-server)基于nats增加了消息持久化，即最少一次投递语义，相应的也有更完备的流控机制。目前的想法是用nats的消息分发辅以nats request-reply做消息QoS，如果在实际应用中，nats的消息QoS不符预期的话，则会考虑切换到nats-streaming。

消息中间件和网关一样，都是游戏服务器架构的基础设施，前者对内简化服务器节点网络拓扑，后者对外屏蔽服务器内部网络拓扑，共同提升服务器的可扩展性。