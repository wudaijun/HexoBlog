关于GS设计的一些心得

纯属个人见解，

### 解耦

包括解耦数据和解耦逻辑，解耦数据是指将相关联的数据放在一块，不要散落在系统各处，比如玩家和公会之间的关系，玩家在公会的所有相关数据(包括职位，贡献等)，都应该属于工会系统，玩家身上只需要一个工会ID作为关联(不应当缓存更多的东西)。从公会的角度来说，它只需要保留公会玩家的ID，以及其在工会的所有相关状态和数据，不应该保留玩家本身更多的东西(哪怕玩家名字)。玩家和工会之间的数据获取，都应该通过Cache之类的中间层去获取，以确保数据只有一份副本。这样做的好处是数据的一致性和安全隔离。

逻辑解耦主要的目的是让系统组件可以独立变化，各个组件之间有边界(函数/模块/Actor/进程)，组件之间遵循某种调用约定(函数调用，RPC等)，这样整个系统职能清晰可控，对于调试，重构都有很大帮助。

### 去除重复

也可以理解为复用，但我更喜欢称其为去除重复，做到复用容易，做到没有重复和冗余难，从代码逻辑上来看，也就是DRY原则。从数据上来看，是指去除不必要的数据冗余。

复用和解耦是软件设计的两个重要设计目标，面向对象的继承，多态，以及大部分的设计模式都围绕这两个核心，用以构造职责清晰，易于测试维护，数据和逻辑都有高度一致性的系统。

### 过度设计

在设计系统时，有时候我们会为了设计而设计，过度抽象和封装，这种过度设计会导致：

- 浪费不必要的开发时间和精力在很简单的逻辑上
- 产生很多不必要的约定和限制，随着项目需求的变更和增长，会成为系统的负担，很有可能不能满足新需求

在这一点上，我体会是比较深的，如何辨别过度设计，我的理解是，首先这个系统是否需要重构，如果系统足够简单，或者足够稳定，那就let it alone。将精力花在核心系统上，并且在必要的时候(已有架构不能满足当前需求或者已经带来大量的复杂度)再进行重构，特别是对于游戏服务器来说，需求迭代很快，提供可靠的服务才是宗旨，不要陷入设计的漩涡。

### 防御式编程

防御是为了隔离错误，而不是为了容忍错误(假装没看到，或者直接无视)。在实际运用中，发现一些同学把Erlang当做C一样用，小心翼翼，对一些非关键性问题选择性的无视，这会将错误扩散出去，对系统调试带来麻烦。对Erlang OTP这种高容错的系统，提倡的是让错误尽早暴露而不是容忍，对于一些严重错误，甚至应该Crash。错误的尽早暴露有利于Debug，找到问题的源头。

### 破窗

保持整洁，可读的代码，持续清理代码中的破窗户，保证代码整体质量。

### 测试

测试的重要性怎么强调也不为过，在开发新功能
