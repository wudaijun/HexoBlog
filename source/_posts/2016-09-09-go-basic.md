---
title: Go 基础学习
layout: post
tags: go
categories: go

---
## 一. 类型系统

### 1. slice

数组切片提供了动态数组的能力，功能和实现都类似于C++ Vector。

    // 初始化一个数组
    var Arr [3]int = [3]int{1,2,3}

    var Slice1 []int
    // 通过数组初始化切片 得到[1 2]
    Slice1 = Arr[:2]
    // 直接创建切片 其中size = 5 capacity = 10 尝试访问[size,capacity]之间的元素会得到运行时错误
    Slice2 := make([]int, 5, 10)
    Slice3 := []int{1,2,3}
    // 从切片创建切片 [:last] 只要last<=capacity 均合法
    Slice4 := Slice2[:8]
    // 切片拷贝 如果两个切片不一样大 会按照较小的数组切片元素个数拷贝
    // 这里的拷贝 可以看作是：先置0 再拷贝
    copy(Slice4, Slice3)

    // 遍历切片[0:size] 多返回值简化了迭代
    for i, v := range Slice1 {
        ...
    }

    // 通过append在size后面添加元素 capacity会自动扩展
    // 同样, 多参数简化了迭代
    Slice3 = append(Slice3, 1,2,3,4,5,6,7,8,9)


<!--more-->

### 2. map

map的使用很简单，唯一需要注意的就是通过delete删除key：

    m := make (map[int]string)
    m[1] = "one"
    m[2] = "two"
    delete(m, 2)
    v, ok := m[2] // 多返回值再一次简化了查询
    if ok {
        // do something when found
    }

### 3. string

Go中的string可以看做字符数组，但与字符数组有几点不同：

    str := "Hello, 世界"
    //str[0] = 'X' // error 不可改变字符串(字面常量)

    // 字符串可通过 + 进行拼接
    str += " !"

    // 以ANSI字符遍历 ch是一个byte n=15(每个中文在UTF-8中占3个字节)
    n := len(str)
    for i := 0; i< n; i++ {
        ch := str[i]
        fmt.Println(i, ch)
    }
    // 以Unicode字符遍历 ch是一个rune 而不是byte 此时遍历得到11个Unicode字符
    for i, ch := range str{
        fmt.Println(i, ch)                
    }

### 4. 值语义和引用语义
     
- 值语义：基本类型和数组，结构体，指针等
- 引用语义：slice，map，channel，interface

### 5. 常量

Go中的常量是无类型的，字面常量(如：3.14, "ok")是无类型的，可以赋给任何满在其值域中的类型。Go预定义了三个常量：true, false, itoa，其中itoa是一个可以被编译器修改的常量，它代表一个整数，在每个const出现时被重置为0，然后itoa每出现一次，其所代表的值即自增一次。itoa通常用来定义枚举值，这类值应用程序不关心具体数值，只需确保其在同一个const枚举声明中不会冲突即可。


	const (		c0 = iota	// c0 == 0		c1 = iota	// c1 == 1		c2 = iota	// c2 == 2	)
	// 根据枚举定义相同表达式的缩写，等价于
	const (		c0 = iota	// c0 == 0		c1			// c1 == 1		c2			// c2 == 2	)

## 二. 顺序编程

### 1. 不定参数&多返回值

不定参数只能是最后一个参数，它实际上是数组切片参数的语法糖：

	// 语法糖 相当于 func myfunc(args []int)
	func myfunc(args ...int){
		for _, arg := range args {        fmt.Println(arg)
	}
	
	// 语法糖 等价于 myfunc([]int{1,3,5,7,9})
	myfunc(1,3,5,7,9)
	
	
多返回值为函数提供了更大的便利性，无需传引用或者专门构造返回值结构体，并且在错误处理方面也更简便，在前面的示例代码中已经初尝甜头。

	// 定义多返回值函数时，可以为返回值指定名字
	func (file *File) Read(b []byte) (n int, err Error){
		// n和err在函数开始时，被自动初始化为空
		...
		... n = xxx
		...
		... err = xxx
		...
		// 直接执行return时，将返回n和err变量的值
		return
	}
	
### 2. 匿名函数&闭包

匿名函数允许函数像变量一样被定义，传递，和使用。Go语言支持随时在代码里定义匿名函数。

	// 赋给变量
	F = func (a, b int) int {
		return a + b
	}
	F(1,2)
	// 直接执行
	func (a, b int) int {
		return a + b
	}(1,2)

                                                                                                                                   
#### 闭包的概念

闭包是可以包含自由(未绑定到特定对象)变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块(由于自由变量包含在代码块中，所以这些自由变量以及它们所引用的对象没有被释放)为自由变量提供绑定的计算环境(作用域)。

#### 闭包的价值

闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一类对象，就是说这些函数可以存储到变量中作为参数传递给其它函数，最重要的是能够被函数动态创建和返回。

#### Go语言中的闭包

Go语言中的闭包同样也会引用到函数外的变量，闭包的实现确保只要闭包还被使用，那么闭包引用的变量会一直存在。 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
	package main
	
	import "fmt"
	
	func main() {
	    var j int = 5
	    a := func()(func()) {
	        var i int = 10
	        return func() {
	            fmt.Printf("i, j: %d, %d\n", i, j)
	        }
	    }()
	
	    a()
	
	    j *= 2
	    a()
	}


## 三. 面向对象：
    
### 1. 类型扩展

	package main
	
	import "fmt"
	
	type Integer int
	
	func (a Integer) Less(b Integer) bool {
	    return a < b
	}
	
	func (a *Integer) Add(b Integer) Integer{
	    return *a + b
	}
	
	func main() {
	    var a Integer = 2
	    fmt.Println( a.Add(1).Less(3) )
	}
	
### 2. 类和继承
	
在Go中，传统意义上的类相当于是对struct的类型扩展：
	
	package main
	
	import "fmt"
	
	type Rect struct{
	    x, y float64
	    w, l float64
	}
	
	func (r Rect) Area() float64{
	    return r.l * r.w
	}
	
	func main(){
	    c := Rect{1,1,4,4}
	    fmt.Println(c.Area())
	}

Go中的继承通过匿名组合实现：

	package main
	
	import "fmt"
	
	type Base struct {
	    Name string
	}
	func (base *Base) Foo() {
	    fmt.Println("Base Foo()")
	}
	func (base *Base) Bar() {
	    fmt.Println("Base Bar()")
	}
	// 以组合的方式 定义继承
	// 当derive.xxx在Derive中未找到时，将从基类Base中查找
	// 也可通过derive.Base.xxx直接引用基类Base的方法或成员
	type Derive struct {
	    Base
	    age int // 这里的同名成员将覆盖Base中的成员
	}
	// 重写基类方法
	func (d *Derive) Bar() {
	    fmt.Println("Derive Bar()")
	}
	
	func main(){
	    b := Base{"name"}
	    d := Derive{b, 99}
	    d.Foo() // == d.Base.Foo() 语法糖，Foo()函数的接收者只能是Base*
	    d.Bar()
	    fmt.Println(d.Name,d.age)
	}

还可以以指针的方式从一个类型派生：

	type Derive struct {
	    *Base
	    ...
	}

这个时候Derive的初始化需要提供一个Base的指针，它存在的意义类似于C++中的虚基类，很少用到。Go将C++面向对象中一些”黑盒子”放到了台面上来，如this指针(作为一个特殊的参数显现出来)，虚函数表(Go中不允许派生类指针到基类指针的隐式转换，也就无需虚函数表来实现多态)，虚基类(通过显式基类指针，简洁明了的实现了这一需求)。

### 3. 访问控制

Go中没有private public等关键字，要使符号对其它包可见，则需要将该符号定义为大写字母开头。如Base中的Name能被其它引用了Base所在包的代码访问到，而Derive中age则不能。Go中没有类级别的访问控制。