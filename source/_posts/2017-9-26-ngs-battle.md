---
title: 探讨服务端回合制战斗系统
layout: post
categories: gameserver
tags: gameserver

---

# 战斗系统

本文记录最近做战斗系统的一些心得和思考，由于我们的战斗系统是回合制的，与《率土之滨》的战斗有些类似，需要服务器计算战斗，客户端以战报的方式回放。我们就以它为实现目标，探讨服务端战斗系统的设计思路，实现一个灵活，可配置，扩展性强的战斗系统。

## 战斗流程

战斗地图是一个X*Y的矩阵，每个参与者(Fighter)初始位于其中一个格子上。战斗开始后，按照回合迭代，达到胜负条件或最大回合数则战斗结束。回合内，英雄按照出手顺序先后行动(Action)，英雄的Action包括移动，释放技能和普攻。

战斗流程是比较简明易懂的，整个战斗系统的难点在于多样的技能实现。每个英雄有N个技能，技能系统可以基于各类事件触发和更新，例如：

- SkillA: 英雄每回合前3次伤害有50%机率使伤害翻倍(最多生效2次)
- SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1，造成伤害降低15%，持续两回合
- SkillC: 英雄受到攻击有60%的几率进行反击(伤害率60%)

以下我们主要围绕灵活的技能系统为主要需求，讨论如何实现一个稳定，可扩展的战斗系统。

## 技能系统

技能分为主动技能(概率触发)和被动技能(相当于战斗开始立即触发)。技能的效果分为瞬时性和持续性两种，前者即像普通一样立即造成伤害(其实普攻也可以看做技能的一种)，后者指技能效果包含状态性，有自己的生命周期和状态更新，如Dot伤害，无法移动，沉默等，这个状态通常叫做Buff，关于技能和Buff的区别我的理解是，技能是Buff的静态容器，是永久的，Buff是技能触发后的实现效果，是动态的。瞬时伤害的技能也可以通过Buff实现，只不过这个Buff生命周期很短，在造成伤害后就消失了。关于Buff的详细实现我们放到后面，我们先看技能系统本身。

考虑到技能以后的扩展性和可维护性，对其尽可能做抽象是有必要的，抽象出公共的流程，将可变量配置化，可以提升系统稳定性和扩展性，也方便后期做测试。技能本身包含几个阶段：技能触发(概率触发，战斗开始触发)，目标选取(敌军/友军，一个/多个)，技能作用(造成伤害，挂接Buff)，前两个是可抽离到配置的，通过通用的技能触发器和目标选取脚本得到技能所需要的信息传给技能作用模块，由于技能作用效果的多样性，目前我们没有对技能作用进行抽象，是通过脚本各个实现的。


## BUFF系统

技能的各种复杂效果都通过BUFF实现，每个Buff都挂于战场某个参与者(Fighter)上，当Fighter阵亡，其上所有的Buff都会被移除(包括Event关联)。BUFF系统是由一个基于战场事件(Event)的回调系统驱动，整个战场在战斗流程中不断抛出各种Event(如回合开始/结束，Fighter普攻/受击/释放技能，伤害结算等)，BUFF注册这些Event并更新自己Owner(Fighter)的状态，来实现灵活强大的技能效果。

### 1. BUFF生命周期

- Start(): Buff开始，即Buff生效节点，注册BUFF的生命周期
- Update(): Buff状态更新，更新Buff的状态并更新战场，对于次数性BUFF(如前N次免伤)，可能调用N次Update，复杂的技能也可能有多个Update函数(关心不同的Event)
- Finish(): Buff的正常结束，当BUff结束条件满足(比如Update了N次，或者持续了N回合)调用
- Cancel(): Buff被冲突(中断)时的处理

以上阐述的是Buff的生命周期，而不是具体实现，在设计Buff时从这四个节点思考，加上事件注册回调机制，基本可以实现绝大部分各式的Buff效果。例如最开始提到的SkillA: 英雄前3次伤害有50%机率使伤害翻倍(最多生效2次)，这是一个持续整场战斗的Buff，它注册两个Update Event:

-  `BEFORE_DAMAGE`(英雄攻击伤害结算前): Update1 中判断如果本回合已触发次数小于2并且满足触发条件(50%概率)，则更新自己的状态(计数器+1)，并使**伤害翻倍**。
-  `ROUND_START`(每回合开始): Update2 中重置Buff状态(计数器)。

目前我们所讨论的Buff都是独立的，有自己生命周期的个体，通过Event注册回调与战斗主流程解耦，这看起来很好。但事与愿违，Buff之间是有相互关联的，这种关系主要有两种：作用于同一属性的Buff之间的公式计算，和Buff之间的冲突免疫关系。

### 2. BUFF属性作用

仍然是我们前面的SkillA技能，我们现在来看如何实现伤害翻倍这个Buff，该Buff是SkillA对应的Buff生成的子Buff，它应该被设计为可公用的伤害增加Buff，这个Buff的作用是影响伤害结算流程，按照我们之前的事件注册回调思路，我们可以注册伤害结算这个Event，接收当前算出的伤害，然后*200%并返回新伤害值。如BuffA提升10%伤害，BuffB增加20点真实伤害，BuffC降低20%的伤害，那么最终得到伤害为: `(基础伤害*110%+20)*80%`，这种方案默认公式计算的顺序与Buff挂载顺序一致，，而正确的伤害值应该为`(基础伤害+20)*(1+10%-20%)`，如果要处理这种优先级关系，需要遍历所有注册伤害结算Event的Handler，按照类型排序，再依次处理，如果一旦有同类Buff添加或移除，又要重新计算。这种公式与事件管理做到了一起，是不稳定的。

BuffA,BuffB,BuffC之所以会有复杂的公式计算，在于它们作用于同一属性的不同维度，BuffA,BuffC作用于伤害值的比例增加这一纬度，而BuffB作用于伤害值的绝对值增长这一维度，我们可以将它们分开，作为两个虚拟属性ATTR\_DAMAGE\_ADD, ATTR\_DAMAGE\_MUL存在，允许Buff单独对其修改，但此时的修改是只有加减关系的，避免了优先级的问题，在伤害结算时，用(基础伤害+ATTR\_DMAGE\_ADD)*ATTR\_DAMAGE\_MUL即可。

这种实现方式有两个好处，一是解决了优先级问题，二是通过虚拟属性系统，解耦和公式计算(属于战斗核心流程)和Event系统(外部Buff)。

一句话概括，**Buff通过属性来影响战斗流程**。这种理念是非常重要的，比如沉默，眩晕等效果，如果没有虚拟属性，沉默Buff会注册EVENT\_BEFORE\_SKILL(Fighter释放技能前)这个Event，并且返回false来告知战斗系统它当前不能释放技能。同样，眩晕Buff会注册Fighter EVENT\_BEFORE\_MOVE, EVENT\_BEFORE\_ATTACK, EVENT\_BEFORE\_SKILL三个Event来实现眩晕效果，一来整个战斗流程每次都要合并各类Event的各种返回值(并且EventHandler得不到统一的接口抽象)，效率低下，二来战斗流程不应该依赖外部EventHandler的实现，它只关心值本身(能否移动，能否施法等)，因此虚拟属性本身实际上起一个依赖倒置的作用。如果使用虚拟属性，那么沉默Buff会在ATTR\_FORBIDEN\_SKILL这个属性上+1，眩晕同理，这样战斗流程在Fighter尝试施放技能时，获取Fighter的ATTR\_FORBIDEN\_SKILL属性，如果>0，则不能施法，即可。

再回到我们的SkillA上:

	// SkillA对应的技能Buff
	func (self *SkillABuff) Start() 
	{
		// 这里将Start和Update流程合并了
		EventMgr.AddEventListener(EVENT_BEFORE_DAMAGE, fighter.Id, func() {
			// 如果当前回合触发次数<2 并且概率50%满足
			if self.triggerCnt <2 && ProbHappen(0.5) {
				b := NewAttrBuff(ATTR_DAMAGE_MUL, 1.0, fighter) // 伤害翻倍的子Buff
				fighter.AddBuff(b)
				
				// 注册Fighter伤害结算完成 因为伤害翻倍只生效一次
				listenerId := EventMgr.AddEventListener(EVENT_AFTER_DAMAGE, fighter.Id, func() {
					// RemoveBuff会调用buff的Finish流程
					fighter.RemoveBuff(b)
					EventMgr.DelEventListener(listenerId)
				})
				self.triggerCnt++
			}
		}
	}
	
	// 通用属性Buff的Start流程 直接更新Owner的属性
	func (b *AttrBuff) Start() {
		b.fighter.UpdateAttr(b.AttrType, b.AttrValue)
	}
	func (b *AttrBuff) Finish() {
		b.fighter.UpdateAttr(b.AttrType, -b.AttrValue)
	}
	
	// 战斗流程 伤害结算部分
	baseDmg := ...
	EventMgr.FireEvent(EVENT_BEFORE_DAMAGE, fighter.Id)
	add := fighter.GetAttr(ATTR_DAMAGE_ADD)
	mul := fighter.GetAttr(ATTR_DAMAGE_MUL)
	dmg := (baseDmg+add)*mul
	... // 计算对方免伤效果，算出最终伤害
	EventMgr.FireEvent(EVENT_AFTER_DAMAGE, fighter.Id)
	

### 3. BUFF相互关系

- Buff 免疫: 	即该BUFF生效时，后面来的哪些BUFF不能生效，如BKB免疫眩晕
- Buff 冲突:  即该BUFF生效时，可以被后面的那些BUFF冲掉，如减速可以被眩晕打断
- Buff 叠加:  两种同类增益或减益BUFF同时生效时，按照某个规则进行BUFF效果重新计算生成

Buff的冲突免疫关系是一个可抽象的流程，每个Buff的冲突免疫关系可以配置化，在挂载Buff时统一处理，至于Buff叠加，在Buff B的Start节点中，判断是否有指定Buff A存在，如果存在，修正BuffB的效果(或移除已有BuffA)，是个特例流程。


## 属性系统

属性系统针对Fighter的各种属性进行管理，属性系统包括K-V Map和公式计算两部分，前面我们讲到通过虚拟属性来完成Buff与战斗流程间的解耦，那么K-V Map的Key有如下几种:

- 固定属性: 当前不受Buff影响的属性，无需公式计算直接获取即可。如Fighter当前血量，位置信息等
- 基础属性: 受Buff影响的属性的基础值，如Fighter进入战斗时的初始攻击力，防御力等，基础属性在战斗过程中不变
- Buff属性: 基础属性的可变部分，由各类Buff修改，如攻击力增加值(绝对值)，防御力加成(百分比)
- 虚拟属性: 如禁足，沉默，伤害加成等，这些属性原本Fighter上面没有，属于战斗流程需要，也由Buff修改

我将属性管理器K-V Map保存的"属性"称为属性维度，它们是Buff操作属性的最小粒度，每个属性维度都是纯加减运算，不受Buff先后顺序的影响。对最终属性的计算，由公式计算系统，比如: 最终攻击力 = (攻击力基础值+攻击力增加值)*(1+攻击力加成值)，战斗流程关心Fighter最终攻击力，Buff系统关心其影响的某个属性维度(如攻击力增加值或攻击力加成值)，中间的这一块就是公式计算，将公式计算抽象出来的好处是公式系统可独立变化，甚至可以将公式配置化。属性的计算过程对战斗流程来说是透明的，这给属性维度和公式计算的变更带来的很大的灵活度。

## 其它扩展

前面介绍了SkillA的实现，来看看SkillB和SkillC:

- SkillB: 诅咒一片区域（以一个敌方为中心的3*3格子）的敌人，使其攻击距离减1，造成伤害降低15%，持续两回合
	- 技能目标选取规则中，配置攻击范围内一个敌人，技能作用脚本中，获取到该目标周围九宫格所有的敌人，对它们施加两个持续两回合的属性Buff(攻击距离-1，造成伤害-15%)。
- SkillC: 英雄受到攻击有60%的几率进行反击(伤害率60%)
	- BuffC注册Fighter受到攻击后的事件，判断是否产生反击效果(60%几率)，如果是，产生反击属性子Buff,将Fighter的反击属性+1，之后战斗流程通过反击属性完成反击，反击完成后BuffC移除子Buff。整体思路与SkillA类似，只不过SkillA通过伤害翻倍来影响战斗伤害计算，而SkillC通过反击属性来影响战斗后续流程。

到这里，战斗系统的主要组件就已经介绍得差不多了，总结起来，核心思路是将相对稳定的核心战斗流程和相对动态的技能Buff扩展隔离开来，战斗流程通过事件系统来解耦外部Buff脚本，Buff通过属性系统来反馈到战斗流程。在构建的过程中，还要时刻关注到哪些是易变的，比如计算公式(如伤害计算公式)，将这一块单独抽出来，封装成模块甚至抽离到配置，尽量将功能做到模块化，离线化，方便模块的扩展和测试。

目前我们的讨论战斗系统还比较简陋，技能效果还只针对于Fighter，如果有技能会影响到整个战场的全局信息(如地形，天气)，比如我们要实现一个技能，该技能效果是可以使九宫格地形陷入腐蚀状态5s，在此期间踏入该区域的敌人，会受到持续伤害，考虑到这类技能的可扩展性，我们目前的思路是，将该技能做成一个"Fighter"，该Fighter在创建后，注册所有Fighter的移动事件，当发现其它Fighter进入到它维护的腐蚀区域时，施加一个持续伤害Buff，当Fighter走出腐蚀区域时，移除该Buff，当5s结束后，销毁自身。之所以将其做成一个Fighter而不是一个Buff，是考虑到这类技能的扩展性，比如如果这团腐蚀区域是有AI的，那么它应该有出手速度和移动策略，这方面来讲，它应该是一个"Fighter"，从这个角度来看，所以Fighter能做的事情，Buff都能做到，也算是个终极的解决方案了。具体细节还没有实践，仅仅是思路。

我们没有展开的另一点是关于战斗流程的，前面我们一直讨论如何抽离变化，将战斗流程"固化"下来，不要交给Buff系统去任意递归迭代，但随着战斗系统功能增长，战斗流程仍然会逐渐膨胀，比如普通流程，缴械，反击，吸血等子流程会越来越多，在这一点上后续也需要考虑去模块化管理这些子流程，另一个前面提到过的思路是，将普攻作为特殊技能来实现，这样技能和普攻的很多效果(吸血，AOE等)可以通过一套代码来实现。这些都是我们还在探索中的。




