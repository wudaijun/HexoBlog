---
title: 虚拟存储器
layout: post
categories: os
tags: os
---

## 虚拟存储器的意义

虚拟存储器提供了三个重要的能力：

- 将主存看作是存储在磁盘上的高速缓存，并根据需要在磁盘和主存中传送数据，高效地运用主存
- 为每个进程提供一致性的地址空间，简化了存储器管理
- 保护每个进程的地址空间不被其它进程破坏

下面分别从这三个方面来谈虚拟存储器

<!--more-->

### 1. 内存是磁盘的Cache

虚拟存储器和物理存储器一样，都分页管理，并且页大小是一致的。在任意时刻，虚拟页面(VP)的集合都分为三个不相交的子集：

- 未分配：VM系统还未分配或创建的页，没有任何数据和它们相关联，因此不占用任何磁盘空间
- 已缓存：当前缓存在物理存储器中的已分配页
- 未缓存：没有缓存在物理存储器中的已分配页

同任何缓存一样，虚拟存储系统必须有某种方法来判定一个虚拟页是否被缓存在主存中，如果是，系统还必须确认这个虚拟页放在哪个物理页中，如果不命中，系统需要判断这个虚拟页存放在磁盘的哪个位置，并且该磁盘对应数据加载到主存中，并且在必要时，选择一个牺牲页(页面调度)。VM通过页表(page table)来维护虚拟页的状态和当前实际地址(主存地址/磁盘地址)：

![]("assets/image/os/page_table.png")

每个进程都有一份页表，页表本身是进程数据的一部分，操作系统负责维护页表的内容，并在磁盘和主存之间来回传送页。CPU通过虚拟地址访问主存时，MMU会先查看页表中该虚拟地址的页表条目：

- 已缓存：如果页表条目标志位为已缓存，MMU则取出对应的物理页面地址，返回给CPU
- 未缓存：如果页表条目标志位为未缓存，则DRAM缓存不命中，又称为缺页(page fault)，此时会触发一个缺页异常，缺页异常会调用缺页异常处理程序，该程序选择一个牺牲页VP2(如果VP2已经被修改了，则将其写回磁盘)，更新VP2的页表条目为未缓存，之后内核从磁盘拷贝目标页VP1到物理页，更新VP1的页表条目，最后返回。此时，页面置换已经完成，当异常处理程序返回时，会重新发起导致缺页的指令，而此时VP1对应的页表条目状态为已缓存，即按照页命中流程正常处理
- 未分配：导致非法地址访问，段错误(segment fault)

巨大的不命中开销(磁盘读写效率比主存低10000倍)驱动着整个DRAM缓存设计的方方面面，由于磁盘读第一个字节的效率是读连续字节的效率的100000倍，因此页不能太小，通常是在4KB~2MB之间，并且DRAM Cache是全相连的，也就是说任何虚拟页都可以放置在任何的物理页中，而对于不命中的替换算法也更为精密，最后，由于对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。DRAM通常都工作得很好，这是因为程序的局部性(时间局部性和空间局部性)原理，但是如果程序的常驻集(工作集)超过了DRAM的大小，则会导致页面不断被换入换出，也就是页面颠簸。

另外，前面我们讨论的页面调度，都是在不命中发生时，才换入页面，这种策略称为按需页面调度(demand paging)，也可以采用其它方法，比如尝试预测不命中，在页面实际被引用之前就换入页面。目前，所有现代系统使用的都是按需页面调度的方式。

![]("assets/image/os/address-translation.png")


### 2. 虚拟存储器提供的存储器管理

由于每个进程都有独立的页表，因此也提供了一个独立的虚拟地址空间，多个虚拟页面可以映射到同一个共享物理物理上。独立虚拟地址空间和按需调度的结合，对系统中存储器的使用和管理有深远的影响。VM机制简化了链接，加载，代码和数据共享，以及应用程序的存储器分配。

- 简化链接：独立的地址空间，允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。如Linux系统上每个进程都使用类似的存储器格式(.text,.data)， 这样的一致性极大地简化了链接器的设计与实现，允许链接器生成全链接的可执行文件，这些可执行文件独立于物理存储器中的代码和数据的最终位置。

- 简化加载：虚拟存储器还可以很容易地实现可执行文件和共享对象文件的加载，要把可执行文件加载到内存中，系统先分配虚拟页的一个连续的块(chunk)，将页表条目指向目标文件中的适当位置，并且标记为未缓存的，即可将可执行文件中的指定节加载到虚拟内存中。需要注意的是，此时文件并未被真正加载到物理内存中，而是要等每个页初次被引用时，才会真正执行页面调入(按需调度)。另外，虽然分配的虚拟内存是连续的，但是具体缓存的物理页面，可以是离散的。

- 简化存储器分配：虚拟存储器为用户提供一个简单的分配额外存储器的机制，当程序要求额外的堆空间时(如调用malloc)，操作系统分配k个连续的存储器页面，并且将它们映射到物理存储器中的任意位置的k个物理页面。由于页表的存在，存储系统没有必要分配k个连续的物理页，页面可以随机分散在物理存储器中

### 3. 虚拟存储器提供的存储器保护

由于每个进程都有自己的独立虚拟地址空间，因此分离不同进程的私有存储器变得很容易。但进程私有存储器和共享存储器仍然需要访问控制(只读，可写等)，这只需要在页表标志位上加上可读，可写等许可位来控制即可。如果一些指令违反了许可条件，CPU会触发异常，Unix Shell将这种异常报告为"段错误"(segmentation fault)。
